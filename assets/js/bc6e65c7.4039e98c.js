"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1678],{6771:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>g});var r=t(5893),n=t(3905);const i={id:"elastic_aggregation",title:"Overview"},s=void 0,o={unversionedId:"overview/elastic_aggregation",id:"overview/elastic_aggregation",title:"Overview",description:"In order to execute Elasticsearch aggregation requests, you first must specify the type of the aggregation along with the corresponding parameters for that type.",source:"@site/../modules/docs/target/mdoc/overview/elastic_aggregation.md",sourceDirName:"overview",slug:"/overview/elastic_aggregation",permalink:"/zio-elasticsearch/overview/elastic_aggregation",draft:!1,unlisted:!1,editUrl:"https://github.com/lambdaworks/zio-elasticsearch/edit/main/docs/overview/elastic_aggregation.md",tags:[],version:"current",frontMatter:{id:"elastic_aggregation",title:"Overview"},sidebar:"docs",previous:{title:"Wildcard Query",permalink:"/zio-elasticsearch/overview/queries/elastic_query_wildcard"},next:{title:"Bucket Selector Aggregation",permalink:"/zio-elasticsearch/overview/aggregations/elastic_aggregation_bucket_selector"}},c={},g=[];function l(e){const a=Object.assign({p:"p",code:"code",pre:"pre"},(0,n.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(a.p,{children:["In order to execute Elasticsearch aggregation requests, you first must specify the type of the aggregation along with the corresponding parameters for that type.\nAggregations are described with the ",(0,r.jsx)(a.code,{children:"ElasticAggregation"})," data type, which can be constructed from the DSL methods found under the following import:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-scala",children:"import zio.elasticsearch.ElasticAggregation._\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Aggregation DSL methods that require a field solely accept field types that are defined as Elasticsearch primitives.\nYou can pass field names simply as strings, or you can use the type-safe aggregation methods that make use of ZIO Schema's accessors.\nAn example with a ",(0,r.jsx)(a.code,{children:"max"})," aggregation is shown below:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-scala",children:'import zio.elasticsearch.ElasticAggregation._\n\nfinal case class User(id: Int, name: String, age: Int)\n\nobject User {\n  implicit val schema: Schema.CaseClass3[Int, String, Int, User] =\n    DeriveSchema.gen[User]\n\n  val (id, name, age) = schema.makeAccessors(FieldAccessorBuilder)\n}\n\nmaxAggregation(name = "maxAggregation", field = "age")\n\n// type-safe method\nmaxAggregation(name = "maxAggregation", field = User.age)\n'})}),"\n",(0,r.jsxs)(a.p,{children:["You can also represent a field from nested structures with type-safe aggregation methods, using the ",(0,r.jsx)(a.code,{children:"/"})," operator on accessors:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.elasticsearch._\nimport zio.elasticsearch.ElasticAggregation._\nimport zio.schema.annotation.fieldName\nimport zio.schema.{DeriveSchema, Schema}\n\nfinal case class Name(\n  @fieldName("first_name")\n  firstName: String,\n  @fieldName("last_name")\n  lastName: String\n)\n\nobject Name {\n  implicit val schema: Schema.CaseClass2[String, String, Name] = DeriveSchema.gen[Name]\n\n  val (firstName, lastName) = schema.makeAccessors(FieldAccessorBuilder)\n}\n\nfinal case class User(id: String, name: Name, email: String, age: Int)\n\nobject User {\n  implicit val schema: Schema.CaseClass4[String, Name, String, Int, User] = \n    DeriveSchema.gen[User]\n\n  val (id, name, email, age) = schema.makeAccessors(FieldAccessorBuilder)\n}\n\ntermsAggregation(name = "termsAggregation", field = "name.first_name")\n\n// type-safe method\ntermsAggregation(name = "termsAggregation", field = User.name / Name.firstName)\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Accessors also have a ",(0,r.jsx)(a.code,{children:"suffix"})," method, in case you want to use one in aggregations:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-scala",children:'ElasticAggregation.cardinality(name = "cardinalityAggregation", field = "email.keyword")\n\n// type-safe method\nElasticAggregation.cardinality(name = "cardinalityAggregation", field = User.email.suffix("keyword"))\n'})}),"\n",(0,r.jsxs)(a.p,{children:["In case the suffix is ",(0,r.jsx)(a.code,{children:'"keyword"'})," or ",(0,r.jsx)(a.code,{children:'"raw"'})," you can use ",(0,r.jsx)(a.code,{children:"keyword"})," and ",(0,r.jsx)(a.code,{children:"raw"})," methods respectively."]}),"\n",(0,r.jsxs)(a.p,{children:["Now, after describing an aggregation, you can pass it to the ",(0,r.jsx)(a.code,{children:"aggregate"}),"/",(0,r.jsx)(a.code,{children:"search"})," method to obtain the ",(0,r.jsx)(a.code,{children:"ElasticRequest"})," corresponding to that aggregation:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-scala",children:'import zio.elasticsearch.ElasticAggregation._\nimport zio.elasticsearch.ElasticQuery._\n\nElasticRequest.aggregate(index = IndexName("index"), aggregation = termsAggregation(name = "termsAggregation", field = "name.first_name.keyword"))\nElasticRequest.search(IndexName("index"), query = matchAll, aggregation = termsAggregation(name = "termsAggregation", field = "name.first_name.keyword"))\n\n// type-safe methods\nElasticRequest.aggregate(index = IndexName("index"), aggregation = termsAggregation(name = "termsAggregation", field = User.name / Name.firstName.keyword))\nElasticRequest.search(index = IndexName("index"), query = matchAll, aggregation = termsAggregation(name = "termsAggregation", field = User.name / Name.firstName.keyword))\n\n'})})]})}const m=function(e={}){const{wrapper:a}=Object.assign({},(0,n.ah)(),e.components);return a?(0,r.jsx)(a,Object.assign({},e,{children:(0,r.jsx)(l,e)})):l(e)}},3905:(e,a,t)=>{t.d(a,{ah:()=>g});var r=t(7294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var c=r.createContext({}),g=function(e){var a=r.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},l={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},m=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=g(t),h=n,p=d["".concat(c,".").concat(h)]||d[h]||l[h]||i;return t?r.createElement(p,s(s({ref:a},m),{},{components:t})):r.createElement(p,s({ref:a},m))}));m.displayName="MDXCreateElement"}}]);